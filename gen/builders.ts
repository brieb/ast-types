/* !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!! */
import * as K from "./kinds";
import * as N from "./nodes";

export interface SourceLocationBuilder {
  <T = {}>(start: K.PositionKind, end: K.PositionKind, source?: string | null): N.SourceLocation & T;
  from<T = {}>(
    params: {
      end: K.PositionKind,
      source?: string | null,
      start: K.PositionKind
    }
  ): N.SourceLocation & T;
}

export interface PositionBuilder {
  <T = {}>(line: number, column: number): N.Position & T;
  from<T = {}>(
    params: {
      column: number,
      line: number
    }
  ): N.Position & T;
}

export interface FileBuilder {
  <T = {}>(program: K.ProgramKind, name?: string | null): N.File & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name?: string | null,
      program: K.ProgramKind
    }
  ): N.File & T;
}

export interface ProgramBuilder {
  <T = {}>(body: K.StatementKind[]): N.Program & T;
  from<T = {}>(
    params: {
      body: K.StatementKind[],
      comments?: K.CommentKind[] | null,
      directives?: K.DirectiveKind[],
      loc?: K.SourceLocationKind | null
    }
  ): N.Program & T;
}

export interface IdentifierBuilder {
  <T = {}>(name: string): N.Identifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name: string,
      optional?: boolean,
      typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
    }
  ): N.Identifier & T;
}

export interface BlockStatementBuilder {
  <T = {}>(body: K.StatementKind[]): N.BlockStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind[],
      comments?: K.CommentKind[] | null,
      directives?: K.DirectiveKind[],
      loc?: K.SourceLocationKind | null
    }
  ): N.BlockStatement & T;
}

export interface EmptyStatementBuilder {
  <T = {}>(): N.EmptyStatement & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.EmptyStatement & T;
}

export interface ExpressionStatementBuilder {
  <T = {}>(expression: K.ExpressionKind): N.ExpressionStatement & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.ExpressionStatement & T;
}

export interface IfStatementBuilder {
  <T = {}>(
    test: K.ExpressionKind,
    consequent: K.StatementKind,
    alternate?: K.StatementKind | null
  ): N.IfStatement & T;
  from<T = {}>(
    params: {
      alternate?: K.StatementKind | null,
      comments?: K.CommentKind[] | null,
      consequent: K.StatementKind,
      loc?: K.SourceLocationKind | null,
      test: K.ExpressionKind
    }
  ): N.IfStatement & T;
}

export interface LabeledStatementBuilder {
  <T = {}>(label: K.IdentifierKind, body: K.StatementKind): N.LabeledStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind,
      comments?: K.CommentKind[] | null,
      label: K.IdentifierKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.LabeledStatement & T;
}

export interface BreakStatementBuilder {
  <T = {}>(label?: K.IdentifierKind | null): N.BreakStatement & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      label?: K.IdentifierKind | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.BreakStatement & T;
}

export interface ContinueStatementBuilder {
  <T = {}>(label?: K.IdentifierKind | null): N.ContinueStatement & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      label?: K.IdentifierKind | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ContinueStatement & T;
}

export interface WithStatementBuilder {
  <T = {}>(object: K.ExpressionKind, body: K.StatementKind): N.WithStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      object: K.ExpressionKind
    }
  ): N.WithStatement & T;
}

export interface SwitchStatementBuilder {
  <T = {}>(
    discriminant: K.ExpressionKind,
    cases: K.SwitchCaseKind[],
    lexical?: boolean
  ): N.SwitchStatement & T;
  from<T = {}>(
    params: {
      cases: K.SwitchCaseKind[],
      comments?: K.CommentKind[] | null,
      discriminant: K.ExpressionKind,
      lexical?: boolean,
      loc?: K.SourceLocationKind | null
    }
  ): N.SwitchStatement & T;
}

export interface SwitchCaseBuilder {
  <T = {}>(test: K.ExpressionKind | null, consequent: K.StatementKind[]): N.SwitchCase & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      consequent: K.StatementKind[],
      loc?: K.SourceLocationKind | null,
      test?: K.ExpressionKind | null
    }
  ): N.SwitchCase & T;
}

export interface ReturnStatementBuilder {
  <T = {}>(argument: K.ExpressionKind | null): N.ReturnStatement & T;
  from<T = {}>(
    params: {
      argument?: K.ExpressionKind | null,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ReturnStatement & T;
}

export interface ThrowStatementBuilder {
  <T = {}>(argument: K.ExpressionKind): N.ThrowStatement & T;
  from<T = {}>(
    params: {
      argument: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ThrowStatement & T;
}

export interface TryStatementBuilder {
  <T = {}>(
    block: K.BlockStatementKind,
    handler?: K.CatchClauseKind | null,
    finalizer?: K.BlockStatementKind | null
  ): N.TryStatement & T;
  from<T = {}>(
    params: {
      block: K.BlockStatementKind,
      comments?: K.CommentKind[] | null,
      finalizer?: K.BlockStatementKind | null,
      guardedHandlers?: K.CatchClauseKind[],
      handler?: K.CatchClauseKind | null,
      handlers?: K.CatchClauseKind[],
      loc?: K.SourceLocationKind | null
    }
  ): N.TryStatement & T;
}

export interface CatchClauseBuilder {
  <T = {}>(
    param: K.PatternKind | null | undefined,
    guard: K.ExpressionKind | null | undefined,
    body: K.BlockStatementKind
  ): N.CatchClause & T;
  from<T = {}>(
    params: {
      body: K.BlockStatementKind,
      comments?: K.CommentKind[] | null,
      guard?: K.ExpressionKind | null,
      loc?: K.SourceLocationKind | null,
      param?: K.PatternKind | null
    }
  ): N.CatchClause & T;
}

export interface WhileStatementBuilder {
  <T = {}>(test: K.ExpressionKind, body: K.StatementKind): N.WhileStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      test: K.ExpressionKind
    }
  ): N.WhileStatement & T;
}

export interface DoWhileStatementBuilder {
  <T = {}>(body: K.StatementKind, test: K.ExpressionKind): N.DoWhileStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      test: K.ExpressionKind
    }
  ): N.DoWhileStatement & T;
}

export interface ForStatementBuilder {
  <T = {}>(
    init: K.VariableDeclarationKind | K.ExpressionKind | null,
    test: K.ExpressionKind | null,
    update: K.ExpressionKind | null,
    body: K.StatementKind
  ): N.ForStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind,
      comments?: K.CommentKind[] | null,
      init?: K.VariableDeclarationKind | K.ExpressionKind | null,
      loc?: K.SourceLocationKind | null,
      test?: K.ExpressionKind | null,
      update?: K.ExpressionKind | null
    }
  ): N.ForStatement & T;
}

export interface VariableDeclarationBuilder {
  <T = {}>(
    kind: "var" | "let" | "const",
    declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[]
  ): N.VariableDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[],
      kind: "var" | "let" | "const",
      loc?: K.SourceLocationKind | null
    }
  ): N.VariableDeclaration & T;
}

export interface ForInStatementBuilder {
  <T = {}>(
    left: K.VariableDeclarationKind | K.ExpressionKind,
    right: K.ExpressionKind,
    body: K.StatementKind,
    each?: boolean
  ): N.ForInStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind,
      comments?: K.CommentKind[] | null,
      each?: boolean,
      left: K.VariableDeclarationKind | K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      right: K.ExpressionKind
    }
  ): N.ForInStatement & T;
}

export interface DebuggerStatementBuilder {
  <T = {}>(): N.DebuggerStatement & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.DebuggerStatement & T;
}

export interface FunctionDeclarationBuilder {
  <T = {}>(
    id: K.IdentifierKind,
    params: K.PatternKind[],
    body: K.BlockStatementKind | K.ExpressionKind,
    generator?: boolean,
    expression?: boolean
  ): N.FunctionDeclaration & T;
  from<T = {}>(
    params: {
      async?: boolean,
      body: K.BlockStatementKind | K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      defaults?: (K.ExpressionKind | null)[],
      expression?: boolean,
      generator?: boolean,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      params: K.PatternKind[],
      rest?: K.IdentifierKind | null,
      returnType?: K.TypeAnnotationKind | null,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.FunctionDeclaration & T;
}

export interface FunctionExpressionBuilder {
  <T = {}>(
    id: K.IdentifierKind | null | undefined,
    params: K.PatternKind[],
    body: K.BlockStatementKind | K.ExpressionKind,
    generator?: boolean,
    expression?: boolean
  ): N.FunctionExpression & T;
  from<T = {}>(
    params: {
      async?: boolean,
      body: K.BlockStatementKind | K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      defaults?: (K.ExpressionKind | null)[],
      expression?: boolean,
      generator?: boolean,
      id?: K.IdentifierKind | null,
      loc?: K.SourceLocationKind | null,
      params: K.PatternKind[],
      rest?: K.IdentifierKind | null,
      returnType?: K.TypeAnnotationKind | null,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.FunctionExpression & T;
}

export interface VariableDeclaratorBuilder {
  <T = {}>(id: K.PatternKind, init: K.ExpressionKind | null): N.VariableDeclarator & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.PatternKind,
      init?: K.ExpressionKind | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.VariableDeclarator & T;
}

export interface ThisExpressionBuilder {
  <T = {}>(): N.ThisExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ThisExpression & T;
}

export interface ArrayExpressionBuilder {
  <T = {}>(
    elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[]
  ): N.ArrayExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[],
      loc?: K.SourceLocationKind | null
    }
  ): N.ArrayExpression & T;
}

export interface ObjectExpressionBuilder {
  <T = {}>(
    properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[]
  ): N.ObjectExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[]
    }
  ): N.ObjectExpression & T;
}

export interface PropertyBuilder {
  <T = {}>(
    kind: "init" | "get" | "set",
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
    value: K.ExpressionKind | K.PatternKind
  ): N.Property & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      decorators?: K.DecoratorKind[] | null,
      key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
      kind: "init" | "get" | "set",
      loc?: K.SourceLocationKind | null,
      method?: boolean,
      shorthand?: boolean,
      value: K.ExpressionKind | K.PatternKind
    }
  ): N.Property & T;
}

export interface LiteralBuilder {
  <T = {}>(value: string | boolean | null | number | RegExp): N.Literal & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      regex?: {
        "pattern": string,
        "flags": string
      } | null,
      value?: string | boolean | null | number | RegExp
    }
  ): N.Literal & T;
}

export interface SequenceExpressionBuilder {
  <T = {}>(expressions: K.ExpressionKind[]): N.SequenceExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expressions: K.ExpressionKind[],
      loc?: K.SourceLocationKind | null
    }
  ): N.SequenceExpression & T;
}

export interface UnaryExpressionBuilder {
  <T = {}>(
    operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete",
    argument: K.ExpressionKind,
    prefix?: boolean
  ): N.UnaryExpression & T;
  from<T = {}>(
    params: {
      argument: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete",
      prefix?: boolean
    }
  ): N.UnaryExpression & T;
}

export interface BinaryExpressionBuilder {
  <T = {}>(
    operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "**" | "&" | "|" | "^" | "in" | "instanceof" | "..",
    left: K.ExpressionKind,
    right: K.ExpressionKind
  ): N.BinaryExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      left: K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "**" | "&" | "|" | "^" | "in" | "instanceof" | "..",
      right: K.ExpressionKind
    }
  ): N.BinaryExpression & T;
}

export interface AssignmentExpressionBuilder {
  <T = {}>(
    operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=",
    left: K.PatternKind,
    right: K.ExpressionKind
  ): N.AssignmentExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      left: K.PatternKind,
      loc?: K.SourceLocationKind | null,
      operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=",
      right: K.ExpressionKind
    }
  ): N.AssignmentExpression & T;
}

export interface UpdateExpressionBuilder {
  <T = {}>(operator: "++" | "--", argument: K.ExpressionKind, prefix: boolean): N.UpdateExpression & T;
  from<T = {}>(
    params: {
      argument: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      operator: "++" | "--",
      prefix: boolean
    }
  ): N.UpdateExpression & T;
}

export interface LogicalExpressionBuilder {
  <T = {}>(
    operator: "||" | "&&" | "??",
    left: K.ExpressionKind,
    right: K.ExpressionKind
  ): N.LogicalExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      left: K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      operator: "||" | "&&" | "??",
      right: K.ExpressionKind
    }
  ): N.LogicalExpression & T;
}

export interface ConditionalExpressionBuilder {
  <T = {}>(
    test: K.ExpressionKind,
    consequent: K.ExpressionKind,
    alternate: K.ExpressionKind
  ): N.ConditionalExpression & T;
  from<T = {}>(
    params: {
      alternate: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      consequent: K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      test: K.ExpressionKind
    }
  ): N.ConditionalExpression & T;
}

export interface NewExpressionBuilder {
  <T = {}>(
    callee: K.ExpressionKind,
    argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[]
  ): N.NewExpression & T;
  from<T = {}>(
    params: {
      arguments: (K.ExpressionKind | K.SpreadElementKind)[],
      callee: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.NewExpression & T;
}

export interface CallExpressionBuilder {
  <T = {}>(
    callee: K.ExpressionKind,
    argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[]
  ): N.CallExpression & T;
  from<T = {}>(
    params: {
      arguments: (K.ExpressionKind | K.SpreadElementKind)[],
      callee: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.CallExpression & T;
}

export interface MemberExpressionBuilder {
  <T = {}>(
    object: K.ExpressionKind,
    property: K.IdentifierKind | K.ExpressionKind,
    computed?: boolean
  ): N.MemberExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      loc?: K.SourceLocationKind | null,
      object: K.ExpressionKind,
      property: K.IdentifierKind | K.ExpressionKind
    }
  ): N.MemberExpression & T;
}

export interface RestElementBuilder {
  <T = {}>(argument: K.PatternKind): N.RestElement & T;
  from<T = {}>(
    params: {
      argument: K.PatternKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
    }
  ): N.RestElement & T;
}

export interface TypeAnnotationBuilder {
  <T = {}>(typeAnnotation: K.FlowTypeKind): N.TypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.FlowTypeKind
    }
  ): N.TypeAnnotation & T;
}

export interface TSTypeAnnotationBuilder {
  <T = {}>(typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind): N.TSTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind
    }
  ): N.TSTypeAnnotation & T;
}

export interface SpreadElementPatternBuilder {
  <T = {}>(argument: K.PatternKind): N.SpreadElementPattern & T;
  from<T = {}>(
    params: {
      argument: K.PatternKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.SpreadElementPattern & T;
}

export interface ArrowFunctionExpressionBuilder {
  <T = {}>(
    params: K.PatternKind[],
    body: K.BlockStatementKind | K.ExpressionKind,
    expression?: boolean
  ): N.ArrowFunctionExpression & T;
  from<T = {}>(
    params: {
      async?: boolean,
      body: K.BlockStatementKind | K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      defaults?: (K.ExpressionKind | null)[],
      expression?: boolean,
      generator?: false,
      id?: null,
      loc?: K.SourceLocationKind | null,
      params: K.PatternKind[],
      rest?: K.IdentifierKind | null,
      returnType?: K.TypeAnnotationKind | null,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.ArrowFunctionExpression & T;
}

export interface ForOfStatementBuilder {
  <T = {}>(
    left: K.VariableDeclarationKind | K.PatternKind,
    right: K.ExpressionKind,
    body: K.StatementKind
  ): N.ForOfStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind,
      comments?: K.CommentKind[] | null,
      left: K.VariableDeclarationKind | K.PatternKind,
      loc?: K.SourceLocationKind | null,
      right: K.ExpressionKind
    }
  ): N.ForOfStatement & T;
}

export interface YieldExpressionBuilder {
  <T = {}>(argument: K.ExpressionKind | null, delegate?: boolean): N.YieldExpression & T;
  from<T = {}>(
    params: {
      argument?: K.ExpressionKind | null,
      comments?: K.CommentKind[] | null,
      delegate?: boolean,
      loc?: K.SourceLocationKind | null
    }
  ): N.YieldExpression & T;
}

export interface GeneratorExpressionBuilder {
  <T = {}>(
    body: K.ExpressionKind,
    blocks: K.ComprehensionBlockKind[],
    filter: K.ExpressionKind | null
  ): N.GeneratorExpression & T;
  from<T = {}>(
    params: {
      blocks: K.ComprehensionBlockKind[],
      body: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      filter?: K.ExpressionKind | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.GeneratorExpression & T;
}

export interface ComprehensionBlockBuilder {
  <T = {}>(left: K.PatternKind, right: K.ExpressionKind, each: boolean): N.ComprehensionBlock & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      each: boolean,
      left: K.PatternKind,
      loc?: K.SourceLocationKind | null,
      right: K.ExpressionKind
    }
  ): N.ComprehensionBlock & T;
}

export interface ComprehensionExpressionBuilder {
  <T = {}>(
    body: K.ExpressionKind,
    blocks: K.ComprehensionBlockKind[],
    filter: K.ExpressionKind | null
  ): N.ComprehensionExpression & T;
  from<T = {}>(
    params: {
      blocks: K.ComprehensionBlockKind[],
      body: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      filter?: K.ExpressionKind | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ComprehensionExpression & T;
}

export interface PropertyPatternBuilder {
  <T = {}>(
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
    pattern: K.PatternKind
  ): N.PropertyPattern & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      pattern: K.PatternKind
    }
  ): N.PropertyPattern & T;
}

export interface ObjectPatternBuilder {
  <T = {}>(
    properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind)[]
  ): N.ObjectPattern & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      decorators?: K.DecoratorKind[] | null,
      loc?: K.SourceLocationKind | null,
      properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind)[],
      typeAnnotation?: K.TypeAnnotationKind | null
    }
  ): N.ObjectPattern & T;
}

export interface ArrayPatternBuilder {
  <T = {}>(elements: (K.PatternKind | K.SpreadElementKind | null)[]): N.ArrayPattern & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      elements: (K.PatternKind | K.SpreadElementKind | null)[],
      loc?: K.SourceLocationKind | null
    }
  ): N.ArrayPattern & T;
}

export interface MethodDefinitionBuilder {
  <T = {}>(
    kind: "constructor" | "method" | "get" | "set",
    key: K.ExpressionKind,
    value: K.FunctionKind,
    staticParam?: boolean
  ): N.MethodDefinition & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      decorators?: K.DecoratorKind[] | null,
      key: K.ExpressionKind,
      kind: "constructor" | "method" | "get" | "set",
      loc?: K.SourceLocationKind | null,
      static?: boolean,
      value: K.FunctionKind
    }
  ): N.MethodDefinition & T;
}

export interface SpreadElementBuilder {
  <T = {}>(argument: K.ExpressionKind): N.SpreadElement & T;
  from<T = {}>(
    params: {
      argument: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.SpreadElement & T;
}

export interface AssignmentPatternBuilder {
  <T = {}>(left: K.PatternKind, right: K.ExpressionKind): N.AssignmentPattern & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      left: K.PatternKind,
      loc?: K.SourceLocationKind | null,
      right: K.ExpressionKind
    }
  ): N.AssignmentPattern & T;
}

export interface ClassPropertyDefinitionBuilder {
  <T = {}>(
    definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind
  ): N.ClassPropertyDefinition & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.ClassPropertyDefinition & T;
}

export interface ClassPropertyBuilder {
  <T = {}>(
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
    value: K.ExpressionKind | null,
    typeAnnotation: K.TypeAnnotationKind | null,
    staticParam?: boolean
  ): N.ClassProperty & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      static?: boolean,
      typeAnnotation?: K.TypeAnnotationKind | null,
      value?: K.ExpressionKind | null,
      variance?: K.VarianceKind | "plus" | "minus" | null
    }
  ): N.ClassProperty & T;
}

export interface ClassBodyBuilder {
  <T = {}>(
    body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassMethodKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]
  ): N.ClassBody & T;
  from<T = {}>(
    params: {
      body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassMethodKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[],
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ClassBody & T;
}

export interface ClassDeclarationBuilder {
  <T = {}>(
    id: K.IdentifierKind | null,
    body: K.ClassBodyKind,
    superClass?: K.ExpressionKind | null
  ): N.ClassDeclaration & T;
  from<T = {}>(
    params: {
      body: K.ClassBodyKind,
      comments?: K.CommentKind[] | null,
      id?: K.IdentifierKind | null,
      implements?: K.TSExpressionWithTypeArgumentsKind[],
      loc?: K.SourceLocationKind | null,
      superClass?: K.ExpressionKind | null,
      superTypeParameters?: K.GenericTypeAnnotationKind[] | null,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.ClassDeclaration & T;
}

export interface ClassExpressionBuilder {
  <T = {}>(
    id: K.IdentifierKind | null | undefined,
    body: K.ClassBodyKind,
    superClass?: K.ExpressionKind | null
  ): N.ClassExpression & T;
  from<T = {}>(
    params: {
      body: K.ClassBodyKind,
      comments?: K.CommentKind[] | null,
      id?: K.IdentifierKind | null,
      implements?: K.TSExpressionWithTypeArgumentsKind[],
      loc?: K.SourceLocationKind | null,
      superClass?: K.ExpressionKind | null,
      superTypeParameters?: K.GenericTypeAnnotationKind[] | null,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.ClassExpression & T;
}

export interface ImportSpecifierBuilder {
  <T = {}>(imported: K.IdentifierKind, local?: K.IdentifierKind | null): N.ImportSpecifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id?: K.IdentifierKind | null,
      imported: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      local?: K.IdentifierKind | null,
      name?: K.IdentifierKind | null
    }
  ): N.ImportSpecifier & T;
}

export interface ImportNamespaceSpecifierBuilder {
  <T = {}>(local?: K.IdentifierKind | null): N.ImportNamespaceSpecifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id?: K.IdentifierKind | null,
      loc?: K.SourceLocationKind | null,
      local?: K.IdentifierKind | null,
      name?: K.IdentifierKind | null
    }
  ): N.ImportNamespaceSpecifier & T;
}

export interface ImportDefaultSpecifierBuilder {
  <T = {}>(local?: K.IdentifierKind | null): N.ImportDefaultSpecifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id?: K.IdentifierKind | null,
      loc?: K.SourceLocationKind | null,
      local?: K.IdentifierKind | null,
      name?: K.IdentifierKind | null
    }
  ): N.ImportDefaultSpecifier & T;
}

export interface ImportDeclarationBuilder {
  <T = {}>(
    specifiers: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[] | undefined,
    source: K.LiteralKind,
    importKind?: "value" | "type"
  ): N.ImportDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      importKind?: "value" | "type",
      loc?: K.SourceLocationKind | null,
      source: K.LiteralKind,
      specifiers?: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[]
    }
  ): N.ImportDeclaration & T;
}

export interface TaggedTemplateExpressionBuilder {
  <T = {}>(tag: K.ExpressionKind, quasi: K.TemplateLiteralKind): N.TaggedTemplateExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      quasi: K.TemplateLiteralKind,
      tag: K.ExpressionKind
    }
  ): N.TaggedTemplateExpression & T;
}

export interface TemplateLiteralBuilder {
  <T = {}>(quasis: K.TemplateElementKind[], expressions: K.ExpressionKind[]): N.TemplateLiteral & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expressions: K.ExpressionKind[],
      loc?: K.SourceLocationKind | null,
      quasis: K.TemplateElementKind[]
    }
  ): N.TemplateLiteral & T;
}

export interface TemplateElementBuilder {
  <T = {}>(
    value: {
      "cooked": string,
      "raw": string
    },
    tail: boolean
  ): N.TemplateElement & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      tail: boolean,
      value: {
        "cooked": string,
        "raw": string
      }
    }
  ): N.TemplateElement & T;
}

export interface SpreadPropertyBuilder {
  <T = {}>(argument: K.ExpressionKind): N.SpreadProperty & T;
  from<T = {}>(
    params: {
      argument: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.SpreadProperty & T;
}

export interface SpreadPropertyPatternBuilder {
  <T = {}>(argument: K.PatternKind): N.SpreadPropertyPattern & T;
  from<T = {}>(
    params: {
      argument: K.PatternKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.SpreadPropertyPattern & T;
}

export interface AwaitExpressionBuilder {
  <T = {}>(argument: K.ExpressionKind | null, all?: boolean): N.AwaitExpression & T;
  from<T = {}>(
    params: {
      all?: boolean,
      argument?: K.ExpressionKind | null,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.AwaitExpression & T;
}

export interface LetStatementBuilder {
  <T = {}>(head: K.VariableDeclaratorKind[], body: K.StatementKind): N.LetStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind,
      comments?: K.CommentKind[] | null,
      head: K.VariableDeclaratorKind[],
      loc?: K.SourceLocationKind | null
    }
  ): N.LetStatement & T;
}

export interface LetExpressionBuilder {
  <T = {}>(head: K.VariableDeclaratorKind[], body: K.ExpressionKind): N.LetExpression & T;
  from<T = {}>(
    params: {
      body: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      head: K.VariableDeclaratorKind[],
      loc?: K.SourceLocationKind | null
    }
  ): N.LetExpression & T;
}

export interface GraphExpressionBuilder {
  <T = {}>(index: number, expression: K.LiteralKind): N.GraphExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.LiteralKind,
      index: number,
      loc?: K.SourceLocationKind | null
    }
  ): N.GraphExpression & T;
}

export interface GraphIndexExpressionBuilder {
  <T = {}>(index: number): N.GraphIndexExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      index: number,
      loc?: K.SourceLocationKind | null
    }
  ): N.GraphIndexExpression & T;
}

export interface JSXAttributeBuilder {
  <T = {}>(
    name: K.JSXIdentifierKind | K.JSXNamespacedNameKind,
    value?: K.LiteralKind | K.JSXExpressionContainerKind | null
  ): N.JSXAttribute & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name: K.JSXIdentifierKind | K.JSXNamespacedNameKind,
      value?: K.LiteralKind | K.JSXExpressionContainerKind | null
    }
  ): N.JSXAttribute & T;
}

export interface JSXIdentifierBuilder {
  <T = {}>(name: string): N.JSXIdentifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name: string,
      optional?: boolean,
      typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
    }
  ): N.JSXIdentifier & T;
}

export interface JSXNamespacedNameBuilder {
  <T = {}>(namespace: K.JSXIdentifierKind, name: K.JSXIdentifierKind): N.JSXNamespacedName & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name: K.JSXIdentifierKind,
      namespace: K.JSXIdentifierKind
    }
  ): N.JSXNamespacedName & T;
}

export interface JSXExpressionContainerBuilder {
  <T = {}>(expression: K.ExpressionKind): N.JSXExpressionContainer & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.JSXExpressionContainer & T;
}

export interface JSXMemberExpressionBuilder {
  <T = {}>(
    object: K.JSXIdentifierKind | K.JSXMemberExpressionKind,
    property: K.JSXIdentifierKind
  ): N.JSXMemberExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      loc?: K.SourceLocationKind | null,
      object: K.JSXIdentifierKind | K.JSXMemberExpressionKind,
      property: K.JSXIdentifierKind
    }
  ): N.JSXMemberExpression & T;
}

export interface JSXSpreadAttributeBuilder {
  <T = {}>(argument: K.ExpressionKind): N.JSXSpreadAttribute & T;
  from<T = {}>(
    params: {
      argument: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.JSXSpreadAttribute & T;
}

export interface JSXElementBuilder {
  <T = {}>(
    openingElement: K.JSXOpeningElementKind,
    closingElement?: K.JSXClosingElementKind | null,
    children?: (K.JSXElementKind | K.JSXExpressionContainerKind | K.JSXFragmentKind | K.JSXTextKind | K.LiteralKind)[]
  ): N.JSXElement & T;
  from<T = {}>(
    params: {
      attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[],
      children?: (K.JSXElementKind | K.JSXExpressionContainerKind | K.JSXFragmentKind | K.JSXTextKind | K.LiteralKind)[],
      closingElement?: K.JSXClosingElementKind | null,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name?: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind,
      openingElement: K.JSXOpeningElementKind,
      selfClosing?: boolean
    }
  ): N.JSXElement & T;
}

export interface JSXOpeningElementBuilder {
  <T = {}>(
    name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind,
    attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[],
    selfClosing?: boolean
  ): N.JSXOpeningElement & T;
  from<T = {}>(
    params: {
      attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[],
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind,
      selfClosing?: boolean
    }
  ): N.JSXOpeningElement & T;
}

export interface JSXClosingElementBuilder {
  <T = {}>(
    name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind
  ): N.JSXClosingElement & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind
    }
  ): N.JSXClosingElement & T;
}

export interface JSXFragmentBuilder {
  <T = {}>(
    openingElement: K.JSXOpeningFragmentKind,
    closingElement: K.JSXClosingFragmentKind,
    children?: (K.JSXElementKind | K.JSXExpressionContainerKind | K.JSXFragmentKind | K.JSXTextKind | K.LiteralKind)[]
  ): N.JSXFragment & T;
  from<T = {}>(
    params: {
      children?: (K.JSXElementKind | K.JSXExpressionContainerKind | K.JSXFragmentKind | K.JSXTextKind | K.LiteralKind)[],
      closingElement: K.JSXClosingFragmentKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      openingElement: K.JSXOpeningFragmentKind
    }
  ): N.JSXFragment & T;
}

export interface JSXTextBuilder {
  <T = {}>(value: string): N.JSXText & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      regex?: {
        "pattern": string,
        "flags": string
      } | null,
      value: string
    }
  ): N.JSXText & T;
}

export interface JSXOpeningFragmentBuilder {
  <T = {}>(): N.JSXOpeningFragment & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.JSXOpeningFragment & T;
}

export interface JSXClosingFragmentBuilder {
  <T = {}>(): N.JSXClosingFragment & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.JSXClosingFragment & T;
}

export interface JSXEmptyExpressionBuilder {
  <T = {}>(): N.JSXEmptyExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.JSXEmptyExpression & T;
}

export interface JSXSpreadChildBuilder {
  <T = {}>(expression: K.ExpressionKind): N.JSXSpreadChild & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.JSXSpreadChild & T;
}

export interface AnyTypeAnnotationBuilder {
  <T = {}>(): N.AnyTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.AnyTypeAnnotation & T;
}

export interface EmptyTypeAnnotationBuilder {
  <T = {}>(): N.EmptyTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.EmptyTypeAnnotation & T;
}

export interface MixedTypeAnnotationBuilder {
  <T = {}>(): N.MixedTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.MixedTypeAnnotation & T;
}

export interface VoidTypeAnnotationBuilder {
  <T = {}>(): N.VoidTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.VoidTypeAnnotation & T;
}

export interface NumberTypeAnnotationBuilder {
  <T = {}>(): N.NumberTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.NumberTypeAnnotation & T;
}

export interface NumberLiteralTypeAnnotationBuilder {
  <T = {}>(value: number, raw: string): N.NumberLiteralTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      raw: string,
      value: number
    }
  ): N.NumberLiteralTypeAnnotation & T;
}

export interface NumericLiteralTypeAnnotationBuilder {
  <T = {}>(value: number, raw: string): N.NumericLiteralTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      raw: string,
      value: number
    }
  ): N.NumericLiteralTypeAnnotation & T;
}

export interface StringTypeAnnotationBuilder {
  <T = {}>(): N.StringTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.StringTypeAnnotation & T;
}

export interface StringLiteralTypeAnnotationBuilder {
  <T = {}>(value: string, raw: string): N.StringLiteralTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      raw: string,
      value: string
    }
  ): N.StringLiteralTypeAnnotation & T;
}

export interface BooleanTypeAnnotationBuilder {
  <T = {}>(): N.BooleanTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.BooleanTypeAnnotation & T;
}

export interface BooleanLiteralTypeAnnotationBuilder {
  <T = {}>(value: boolean, raw: string): N.BooleanLiteralTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      raw: string,
      value: boolean
    }
  ): N.BooleanLiteralTypeAnnotation & T;
}

export interface NullableTypeAnnotationBuilder {
  <T = {}>(typeAnnotation: K.FlowTypeKind): N.NullableTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.FlowTypeKind
    }
  ): N.NullableTypeAnnotation & T;
}

export interface NullLiteralTypeAnnotationBuilder {
  <T = {}>(): N.NullLiteralTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.NullLiteralTypeAnnotation & T;
}

export interface NullTypeAnnotationBuilder {
  <T = {}>(): N.NullTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.NullTypeAnnotation & T;
}

export interface ThisTypeAnnotationBuilder {
  <T = {}>(): N.ThisTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ThisTypeAnnotation & T;
}

export interface ExistsTypeAnnotationBuilder {
  <T = {}>(): N.ExistsTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ExistsTypeAnnotation & T;
}

export interface ExistentialTypeParamBuilder {
  <T = {}>(): N.ExistentialTypeParam & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ExistentialTypeParam & T;
}

export interface FunctionTypeAnnotationBuilder {
  <T = {}>(
    params: K.FunctionTypeParamKind[],
    returnType: K.FlowTypeKind,
    rest: K.FunctionTypeParamKind | null,
    typeParameters: K.TypeParameterDeclarationKind | null
  ): N.FunctionTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      params: K.FunctionTypeParamKind[],
      rest?: K.FunctionTypeParamKind | null,
      returnType: K.FlowTypeKind,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.FunctionTypeAnnotation & T;
}

export interface FunctionTypeParamBuilder {
  <T = {}>(name: K.IdentifierKind, typeAnnotation: K.FlowTypeKind, optional: boolean): N.FunctionTypeParam & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name: K.IdentifierKind,
      optional: boolean,
      typeAnnotation: K.FlowTypeKind
    }
  ): N.FunctionTypeParam & T;
}

export interface TypeParameterDeclarationBuilder {
  <T = {}>(params: K.TypeParameterKind[]): N.TypeParameterDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      params: K.TypeParameterKind[]
    }
  ): N.TypeParameterDeclaration & T;
}

export interface ArrayTypeAnnotationBuilder {
  <T = {}>(elementType: K.FlowTypeKind): N.ArrayTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      elementType: K.FlowTypeKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.ArrayTypeAnnotation & T;
}

export interface ObjectTypeAnnotationBuilder {
  <T = {}>(
    properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[],
    indexers?: K.ObjectTypeIndexerKind[],
    callProperties?: K.ObjectTypeCallPropertyKind[]
  ): N.ObjectTypeAnnotation & T;
  from<T = {}>(
    params: {
      callProperties?: K.ObjectTypeCallPropertyKind[],
      comments?: K.CommentKind[] | null,
      exact?: boolean,
      indexers?: K.ObjectTypeIndexerKind[],
      loc?: K.SourceLocationKind | null,
      properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[]
    }
  ): N.ObjectTypeAnnotation & T;
}

export interface ObjectTypePropertyBuilder {
  <T = {}>(
    key: K.LiteralKind | K.IdentifierKind,
    value: K.FlowTypeKind,
    optional: boolean
  ): N.ObjectTypeProperty & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      key: K.LiteralKind | K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      optional: boolean,
      value: K.FlowTypeKind,
      variance?: K.VarianceKind | "plus" | "minus" | null
    }
  ): N.ObjectTypeProperty & T;
}

export interface ObjectTypeSpreadPropertyBuilder {
  <T = {}>(argument: K.FlowTypeKind): N.ObjectTypeSpreadProperty & T;
  from<T = {}>(
    params: {
      argument: K.FlowTypeKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ObjectTypeSpreadProperty & T;
}

export interface ObjectTypeIndexerBuilder {
  <T = {}>(id: K.IdentifierKind, key: K.FlowTypeKind, value: K.FlowTypeKind): N.ObjectTypeIndexer & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      key: K.FlowTypeKind,
      loc?: K.SourceLocationKind | null,
      value: K.FlowTypeKind,
      variance?: K.VarianceKind | "plus" | "minus" | null
    }
  ): N.ObjectTypeIndexer & T;
}

export interface ObjectTypeCallPropertyBuilder {
  <T = {}>(value: K.FunctionTypeAnnotationKind): N.ObjectTypeCallProperty & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      static?: boolean,
      value: K.FunctionTypeAnnotationKind
    }
  ): N.ObjectTypeCallProperty & T;
}

export interface VarianceBuilder {
  <T = {}>(kind: "plus" | "minus"): N.Variance & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      kind: "plus" | "minus",
      loc?: K.SourceLocationKind | null
    }
  ): N.Variance & T;
}

export interface QualifiedTypeIdentifierBuilder {
  <T = {}>(
    qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind,
    id: K.IdentifierKind
  ): N.QualifiedTypeIdentifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind
    }
  ): N.QualifiedTypeIdentifier & T;
}

export interface GenericTypeAnnotationBuilder {
  <T = {}>(
    id: K.IdentifierKind | K.QualifiedTypeIdentifierKind,
    typeParameters: K.TypeParameterInstantiationKind | null
  ): N.GenericTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind | K.QualifiedTypeIdentifierKind,
      loc?: K.SourceLocationKind | null,
      typeParameters?: K.TypeParameterInstantiationKind | null
    }
  ): N.GenericTypeAnnotation & T;
}

export interface TypeParameterInstantiationBuilder {
  <T = {}>(params: K.FlowTypeKind[]): N.TypeParameterInstantiation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      params: K.FlowTypeKind[]
    }
  ): N.TypeParameterInstantiation & T;
}

export interface MemberTypeAnnotationBuilder {
  <T = {}>(
    object: K.IdentifierKind,
    property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind
  ): N.MemberTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      object: K.IdentifierKind,
      property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind
    }
  ): N.MemberTypeAnnotation & T;
}

export interface UnionTypeAnnotationBuilder {
  <T = {}>(types: K.FlowTypeKind[]): N.UnionTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      types: K.FlowTypeKind[]
    }
  ): N.UnionTypeAnnotation & T;
}

export interface IntersectionTypeAnnotationBuilder {
  <T = {}>(types: K.FlowTypeKind[]): N.IntersectionTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      types: K.FlowTypeKind[]
    }
  ): N.IntersectionTypeAnnotation & T;
}

export interface TypeofTypeAnnotationBuilder {
  <T = {}>(argument: K.FlowTypeKind): N.TypeofTypeAnnotation & T;
  from<T = {}>(
    params: {
      argument: K.FlowTypeKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TypeofTypeAnnotation & T;
}

export interface TypeParameterBuilder {
  <T = {}>(
    name: string,
    variance?: K.VarianceKind | "plus" | "minus" | null,
    bound?: K.TypeAnnotationKind | null
  ): N.TypeParameter & T;
  from<T = {}>(
    params: {
      bound?: K.TypeAnnotationKind | null,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      name: string,
      variance?: K.VarianceKind | "plus" | "minus" | null
    }
  ): N.TypeParameter & T;
}

export interface ClassImplementsBuilder {
  <T = {}>(id: K.IdentifierKind): N.ClassImplements & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      superClass?: K.ExpressionKind | null,
      typeParameters?: K.TypeParameterInstantiationKind | null
    }
  ): N.ClassImplements & T;
}

export interface InterfaceDeclarationBuilder {
  <T = {}>(
    id: K.IdentifierKind,
    body: K.ObjectTypeAnnotationKind,
    extendsParam: K.InterfaceExtendsKind[]
  ): N.InterfaceDeclaration & T;
  from<T = {}>(
    params: {
      body: K.ObjectTypeAnnotationKind,
      comments?: K.CommentKind[] | null,
      extends: K.InterfaceExtendsKind[],
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.InterfaceDeclaration & T;
}

export interface InterfaceExtendsBuilder {
  <T = {}>(id: K.IdentifierKind): N.InterfaceExtends & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      typeParameters?: K.TypeParameterInstantiationKind | null
    }
  ): N.InterfaceExtends & T;
}

export interface DeclareInterfaceBuilder {
  <T = {}>(
    id: K.IdentifierKind,
    body: K.ObjectTypeAnnotationKind,
    extendsParam: K.InterfaceExtendsKind[]
  ): N.DeclareInterface & T;
  from<T = {}>(
    params: {
      body: K.ObjectTypeAnnotationKind,
      comments?: K.CommentKind[] | null,
      extends: K.InterfaceExtendsKind[],
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.DeclareInterface & T;
}

export interface TypeAliasBuilder {
  <T = {}>(
    id: K.IdentifierKind,
    typeParameters: K.TypeParameterDeclarationKind | null,
    right: K.FlowTypeKind
  ): N.TypeAlias & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      right: K.FlowTypeKind,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.TypeAlias & T;
}

export interface OpaqueTypeBuilder {
  <T = {}>(
    id: K.IdentifierKind,
    typeParameters: K.TypeParameterDeclarationKind | null
  ): N.OpaqueType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      implType: K.FlowTypeKind,
      loc?: K.SourceLocationKind | null,
      superType: K.FlowTypeKind,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.OpaqueType & T;
}

export interface DeclareTypeAliasBuilder {
  <T = {}>(
    id: K.IdentifierKind,
    typeParameters: K.TypeParameterDeclarationKind | null,
    right: K.FlowTypeKind
  ): N.DeclareTypeAlias & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      right: K.FlowTypeKind,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.DeclareTypeAlias & T;
}

export interface DeclareOpaqueTypeBuilder {
  <T = {}>(
    id: K.IdentifierKind,
    typeParameters: K.TypeParameterDeclarationKind | null
  ): N.DeclareOpaqueType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      right: K.FlowTypeKind,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.DeclareOpaqueType & T;
}

export interface TypeCastExpressionBuilder {
  <T = {}>(expression: K.ExpressionKind, typeAnnotation: K.TypeAnnotationKind): N.TypeCastExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.TypeAnnotationKind
    }
  ): N.TypeCastExpression & T;
}

export interface TupleTypeAnnotationBuilder {
  <T = {}>(types: K.FlowTypeKind[]): N.TupleTypeAnnotation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      types: K.FlowTypeKind[]
    }
  ): N.TupleTypeAnnotation & T;
}

export interface DeclareVariableBuilder {
  <T = {}>(id: K.IdentifierKind): N.DeclareVariable & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.DeclareVariable & T;
}

export interface DeclareFunctionBuilder {
  <T = {}>(id: K.IdentifierKind): N.DeclareFunction & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.DeclareFunction & T;
}

export interface DeclareClassBuilder {
  <T = {}>(id: K.IdentifierKind): N.DeclareClass & T;
  from<T = {}>(
    params: {
      body: K.ObjectTypeAnnotationKind,
      comments?: K.CommentKind[] | null,
      extends: K.InterfaceExtendsKind[],
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.DeclareClass & T;
}

export interface DeclareModuleBuilder {
  <T = {}>(id: K.IdentifierKind | K.LiteralKind, body: K.BlockStatementKind): N.DeclareModule & T;
  from<T = {}>(
    params: {
      body: K.BlockStatementKind,
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind | K.LiteralKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.DeclareModule & T;
}

export interface DeclareModuleExportsBuilder {
  <T = {}>(typeAnnotation: K.TypeAnnotationKind): N.DeclareModuleExports & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.TypeAnnotationKind
    }
  ): N.DeclareModuleExports & T;
}

export interface DeclareExportDeclarationBuilder {
  <T = {}>(
    defaultParam: boolean,
    declaration: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | null,
    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[],
    source?: K.LiteralKind | null
  ): N.DeclareExportDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      declaration?: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | null,
      default: boolean,
      loc?: K.SourceLocationKind | null,
      source?: K.LiteralKind | null,
      specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[]
    }
  ): N.DeclareExportDeclaration & T;
}

export interface ExportSpecifierBuilder {
  <T = {}>(local: K.IdentifierKind | null | undefined, exported: K.IdentifierKind): N.ExportSpecifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      exported: K.IdentifierKind,
      id?: K.IdentifierKind | null,
      loc?: K.SourceLocationKind | null,
      local?: K.IdentifierKind | null,
      name?: K.IdentifierKind | null
    }
  ): N.ExportSpecifier & T;
}

export interface ExportBatchSpecifierBuilder {
  <T = {}>(): N.ExportBatchSpecifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.ExportBatchSpecifier & T;
}

export interface DeclareExportAllDeclarationBuilder {
  <T = {}>(source?: K.LiteralKind | null): N.DeclareExportAllDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      source?: K.LiteralKind | null
    }
  ): N.DeclareExportAllDeclaration & T;
}

export interface InferredPredicateBuilder {
  <T = {}>(): N.InferredPredicate & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.InferredPredicate & T;
}

export interface DeclaredPredicateBuilder {
  <T = {}>(value: K.ExpressionKind): N.DeclaredPredicate & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      value: K.ExpressionKind
    }
  ): N.DeclaredPredicate & T;
}

export interface ExportDeclarationBuilder {
  <T = {}>(
    defaultParam: boolean,
    declaration: K.DeclarationKind | K.ExpressionKind | null,
    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[],
    source?: K.LiteralKind | null
  ): N.ExportDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      declaration?: K.DeclarationKind | K.ExpressionKind | null,
      default: boolean,
      loc?: K.SourceLocationKind | null,
      source?: K.LiteralKind | null,
      specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[]
    }
  ): N.ExportDeclaration & T;
}

export interface BlockBuilder {
  <T = {}>(value: string, leading?: boolean, trailing?: boolean): N.Block & T;
  from<T = {}>(
    params: {
      leading?: boolean,
      loc?: K.SourceLocationKind | null,
      trailing?: boolean,
      value: string
    }
  ): N.Block & T;
}

export interface LineBuilder {
  <T = {}>(value: string, leading?: boolean, trailing?: boolean): N.Line & T;
  from<T = {}>(
    params: {
      leading?: boolean,
      loc?: K.SourceLocationKind | null,
      trailing?: boolean,
      value: string
    }
  ): N.Line & T;
}

export interface NoopBuilder {
  <T = {}>(): N.Noop & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.Noop & T;
}

export interface DoExpressionBuilder {
  <T = {}>(body: K.StatementKind[]): N.DoExpression & T;
  from<T = {}>(
    params: {
      body: K.StatementKind[],
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.DoExpression & T;
}

export interface SuperBuilder {
  <T = {}>(): N.Super & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.Super & T;
}

export interface BindExpressionBuilder {
  <T = {}>(object: K.ExpressionKind | null, callee: K.ExpressionKind): N.BindExpression & T;
  from<T = {}>(
    params: {
      callee: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      object?: K.ExpressionKind | null
    }
  ): N.BindExpression & T;
}

export interface DecoratorBuilder {
  <T = {}>(expression: K.ExpressionKind): N.Decorator & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.Decorator & T;
}

export interface MetaPropertyBuilder {
  <T = {}>(meta: K.IdentifierKind, property: K.IdentifierKind): N.MetaProperty & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      meta: K.IdentifierKind,
      property: K.IdentifierKind
    }
  ): N.MetaProperty & T;
}

export interface ParenthesizedExpressionBuilder {
  <T = {}>(expression: K.ExpressionKind): N.ParenthesizedExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.ParenthesizedExpression & T;
}

export interface ExportDefaultDeclarationBuilder {
  <T = {}>(declaration: K.DeclarationKind | K.ExpressionKind): N.ExportDefaultDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      declaration: K.DeclarationKind | K.ExpressionKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.ExportDefaultDeclaration & T;
}

export interface ExportNamedDeclarationBuilder {
  <T = {}>(
    declaration: K.DeclarationKind | null,
    specifiers?: K.ExportSpecifierKind[],
    source?: K.LiteralKind | null
  ): N.ExportNamedDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      declaration?: K.DeclarationKind | null,
      loc?: K.SourceLocationKind | null,
      source?: K.LiteralKind | null,
      specifiers?: K.ExportSpecifierKind[]
    }
  ): N.ExportNamedDeclaration & T;
}

export interface ExportNamespaceSpecifierBuilder {
  <T = {}>(exported: K.IdentifierKind): N.ExportNamespaceSpecifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      exported: K.IdentifierKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.ExportNamespaceSpecifier & T;
}

export interface ExportDefaultSpecifierBuilder {
  <T = {}>(exported: K.IdentifierKind): N.ExportDefaultSpecifier & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      exported: K.IdentifierKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.ExportDefaultSpecifier & T;
}

export interface ExportAllDeclarationBuilder {
  <T = {}>(exported: K.IdentifierKind | null, source: K.LiteralKind): N.ExportAllDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      exported?: K.IdentifierKind | null,
      loc?: K.SourceLocationKind | null,
      source: K.LiteralKind
    }
  ): N.ExportAllDeclaration & T;
}

export interface CommentBlockBuilder {
  <T = {}>(value: string, leading?: boolean, trailing?: boolean): N.CommentBlock & T;
  from<T = {}>(
    params: {
      leading?: boolean,
      loc?: K.SourceLocationKind | null,
      trailing?: boolean,
      value: string
    }
  ): N.CommentBlock & T;
}

export interface CommentLineBuilder {
  <T = {}>(value: string, leading?: boolean, trailing?: boolean): N.CommentLine & T;
  from<T = {}>(
    params: {
      leading?: boolean,
      loc?: K.SourceLocationKind | null,
      trailing?: boolean,
      value: string
    }
  ): N.CommentLine & T;
}

export interface DirectiveBuilder {
  <T = {}>(value: K.DirectiveLiteralKind): N.Directive & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      value: K.DirectiveLiteralKind
    }
  ): N.Directive & T;
}

export interface DirectiveLiteralBuilder {
  <T = {}>(value: string): N.DirectiveLiteral & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      value: string
    }
  ): N.DirectiveLiteral & T;
}

export interface StringLiteralBuilder {
  <T = {}>(value: string): N.StringLiteral & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      regex?: {
        "pattern": string,
        "flags": string
      } | null,
      value: string
    }
  ): N.StringLiteral & T;
}

export interface NumericLiteralBuilder {
  <T = {}>(value: number): N.NumericLiteral & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      extra?: {
        "rawValue": number,
        "raw": string
      },
      loc?: K.SourceLocationKind | null,
      raw?: string | null,
      regex?: {
        "pattern": string,
        "flags": string
      } | null,
      value: number
    }
  ): N.NumericLiteral & T;
}

export interface BigIntLiteralBuilder {
  <T = {}>(value: string | number): N.BigIntLiteral & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      extra?: {
        "rawValue": string,
        "raw": string
      },
      loc?: K.SourceLocationKind | null,
      regex?: {
        "pattern": string,
        "flags": string
      } | null,
      value: string | number
    }
  ): N.BigIntLiteral & T;
}

export interface NullLiteralBuilder {
  <T = {}>(): N.NullLiteral & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      regex?: {
        "pattern": string,
        "flags": string
      } | null,
      value?: null
    }
  ): N.NullLiteral & T;
}

export interface BooleanLiteralBuilder {
  <T = {}>(value: boolean): N.BooleanLiteral & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      regex?: {
        "pattern": string,
        "flags": string
      } | null,
      value: boolean
    }
  ): N.BooleanLiteral & T;
}

export interface RegExpLiteralBuilder {
  <T = {}>(pattern: string, flags: string): N.RegExpLiteral & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      flags: string,
      loc?: K.SourceLocationKind | null,
      pattern: string,
      regex?: {
        "pattern": string,
        "flags": string
      } | null,
      value?: RegExp
    }
  ): N.RegExpLiteral & T;
}

export interface ObjectMethodBuilder {
  <T = {}>(
    kind: "method" | "get" | "set",
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
    params: K.PatternKind[],
    body: K.BlockStatementKind,
    computed?: boolean
  ): N.ObjectMethod & T;
  from<T = {}>(
    params: {
      accessibility?: K.LiteralKind | null,
      async?: boolean,
      body: K.BlockStatementKind,
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      decorators?: K.DecoratorKind[] | null,
      defaults?: (K.ExpressionKind | null)[],
      expression?: boolean,
      generator?: boolean,
      id?: K.IdentifierKind | null,
      key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
      kind: "method" | "get" | "set",
      loc?: K.SourceLocationKind | null,
      params: K.PatternKind[],
      rest?: K.IdentifierKind | null,
      returnType?: K.TypeAnnotationKind | null,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.ObjectMethod & T;
}

export interface ObjectPropertyBuilder {
  <T = {}>(
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
    value: K.ExpressionKind | K.PatternKind
  ): N.ObjectProperty & T;
  from<T = {}>(
    params: {
      accessibility?: K.LiteralKind | null,
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      value: K.ExpressionKind | K.PatternKind
    }
  ): N.ObjectProperty & T;
}

export interface ClassMethodBuilder {
  <T = {}>(
    kind: "get" | "set" | "method" | "constructor",
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
    params: K.PatternKind[],
    body: K.BlockStatementKind,
    computed?: boolean,
    staticParam?: boolean
  ): N.ClassMethod & T;
  from<T = {}>(
    params: {
      async?: boolean,
      body: K.BlockStatementKind,
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      decorators?: K.DecoratorKind[] | null,
      defaults?: (K.ExpressionKind | null)[],
      expression?: boolean,
      generator?: boolean,
      id?: K.IdentifierKind | null,
      key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
      kind: "get" | "set" | "method" | "constructor",
      loc?: K.SourceLocationKind | null,
      params: K.PatternKind[],
      rest?: K.IdentifierKind | null,
      returnType?: K.TypeAnnotationKind | null,
      static?: boolean,
      typeParameters?: K.TypeParameterDeclarationKind | null
    }
  ): N.ClassMethod & T;
}

export interface RestPropertyBuilder {
  <T = {}>(argument: K.ExpressionKind): N.RestProperty & T;
  from<T = {}>(
    params: {
      argument: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.RestProperty & T;
}

export interface ForAwaitStatementBuilder {
  <T = {}>(
    left: K.VariableDeclarationKind | K.ExpressionKind,
    right: K.ExpressionKind,
    body: K.StatementKind
  ): N.ForAwaitStatement & T;
  from<T = {}>(
    params: {
      body: K.StatementKind,
      comments?: K.CommentKind[] | null,
      left: K.VariableDeclarationKind | K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      right: K.ExpressionKind
    }
  ): N.ForAwaitStatement & T;
}

export interface ImportBuilder {
  <T = {}>(): N.Import & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.Import & T;
}

export interface TSQualifiedNameBuilder {
  <T = {}>(
    left: K.IdentifierKind | K.TSQualifiedNameKind,
    right: K.IdentifierKind | K.TSQualifiedNameKind
  ): N.TSQualifiedName & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      left: K.IdentifierKind | K.TSQualifiedNameKind,
      loc?: K.SourceLocationKind | null,
      right: K.IdentifierKind | K.TSQualifiedNameKind
    }
  ): N.TSQualifiedName & T;
}

export interface TSTypeReferenceBuilder {
  <T = {}>(
    typeName: K.IdentifierKind | K.TSQualifiedNameKind,
    typeParameters?: K.TSTypeParameterInstantiationKind | null
  ): N.TSTypeReference & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeName: K.IdentifierKind | K.TSQualifiedNameKind,
      typeParameters?: K.TSTypeParameterInstantiationKind | null
    }
  ): N.TSTypeReference & T;
}

export interface TSTypeParameterInstantiationBuilder {
  <T = {}>(params: K.TSTypeKind[]): N.TSTypeParameterInstantiation & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      params: K.TSTypeKind[]
    }
  ): N.TSTypeParameterInstantiation & T;
}

export interface TSTypeParameterDeclarationBuilder {
  <T = {}>(params: K.TSTypeParameterKind[]): N.TSTypeParameterDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      params: K.TSTypeParameterKind[]
    }
  ): N.TSTypeParameterDeclaration & T;
}

export interface TSAsExpressionBuilder {
  <T = {}>(expression: K.ExpressionKind): N.TSAsExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      extra?: {
        "parenthesized": boolean
      } | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.TSTypeKind
    }
  ): N.TSAsExpression & T;
}

export interface TSNonNullExpressionBuilder {
  <T = {}>(expression: K.ExpressionKind): N.TSNonNullExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSNonNullExpression & T;
}

export interface TSAnyKeywordBuilder {
  <T = {}>(): N.TSAnyKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSAnyKeyword & T;
}

export interface TSBooleanKeywordBuilder {
  <T = {}>(): N.TSBooleanKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSBooleanKeyword & T;
}

export interface TSNeverKeywordBuilder {
  <T = {}>(): N.TSNeverKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSNeverKeyword & T;
}

export interface TSNullKeywordBuilder {
  <T = {}>(): N.TSNullKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSNullKeyword & T;
}

export interface TSNumberKeywordBuilder {
  <T = {}>(): N.TSNumberKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSNumberKeyword & T;
}

export interface TSObjectKeywordBuilder {
  <T = {}>(): N.TSObjectKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSObjectKeyword & T;
}

export interface TSStringKeywordBuilder {
  <T = {}>(): N.TSStringKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSStringKeyword & T;
}

export interface TSSymbolKeywordBuilder {
  <T = {}>(): N.TSSymbolKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSSymbolKeyword & T;
}

export interface TSUndefinedKeywordBuilder {
  <T = {}>(): N.TSUndefinedKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSUndefinedKeyword & T;
}

export interface TSUnknownKeywordBuilder {
  <T = {}>(): N.TSUnknownKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSUnknownKeyword & T;
}

export interface TSVoidKeywordBuilder {
  <T = {}>(): N.TSVoidKeyword & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSVoidKeyword & T;
}

export interface TSThisTypeBuilder {
  <T = {}>(): N.TSThisType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSThisType & T;
}

export interface TSArrayTypeBuilder {
  <T = {}>(elementType: K.TSTypeKind): N.TSArrayType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      elementType: K.TSTypeKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSArrayType & T;
}

export interface TSLiteralTypeBuilder {
  <T = {}>(literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind): N.TSLiteralType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSLiteralType & T;
}

export interface TSUnionTypeBuilder {
  <T = {}>(types: K.TSTypeKind[]): N.TSUnionType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      types: K.TSTypeKind[]
    }
  ): N.TSUnionType & T;
}

export interface TSIntersectionTypeBuilder {
  <T = {}>(types: K.TSTypeKind[]): N.TSIntersectionType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      types: K.TSTypeKind[]
    }
  ): N.TSIntersectionType & T;
}

export interface TSConditionalTypeBuilder {
  <T = {}>(
    checkType: K.TSTypeKind,
    extendsType: K.TSTypeKind,
    trueType: K.TSTypeKind,
    falseType: K.TSTypeKind
  ): N.TSConditionalType & T;
  from<T = {}>(
    params: {
      checkType: K.TSTypeKind,
      comments?: K.CommentKind[] | null,
      extendsType: K.TSTypeKind,
      falseType: K.TSTypeKind,
      loc?: K.SourceLocationKind | null,
      trueType: K.TSTypeKind
    }
  ): N.TSConditionalType & T;
}

export interface TSInferTypeBuilder {
  <T = {}>(typeParameter: K.TSTypeParameterKind): N.TSInferType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeParameter: K.TSTypeParameterKind
    }
  ): N.TSInferType & T;
}

export interface TSTypeParameterBuilder {
  <T = {}>(
    name: string,
    constraint?: K.TSTypeKind | null,
    defaultParam?: K.TSTypeKind | null
  ): N.TSTypeParameter & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      constraint?: K.TSTypeKind | null,
      default?: K.TSTypeKind | null,
      loc?: K.SourceLocationKind | null,
      name: string,
      optional?: boolean,
      typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
    }
  ): N.TSTypeParameter & T;
}

export interface TSParenthesizedTypeBuilder {
  <T = {}>(typeAnnotation: K.TSTypeKind): N.TSParenthesizedType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.TSTypeKind
    }
  ): N.TSParenthesizedType & T;
}

export interface TSFunctionTypeBuilder {
  <T = {}>(parameters: (K.IdentifierKind | K.RestElementKind)[]): N.TSFunctionType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      parameters: (K.IdentifierKind | K.RestElementKind)[],
      typeAnnotation?: K.TSTypeAnnotationKind | null,
      typeParameters?: K.TSTypeParameterDeclarationKind | null
    }
  ): N.TSFunctionType & T;
}

export interface TSConstructorTypeBuilder {
  <T = {}>(parameters: (K.IdentifierKind | K.RestElementKind)[]): N.TSConstructorType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      parameters: (K.IdentifierKind | K.RestElementKind)[],
      typeAnnotation?: K.TSTypeAnnotationKind | null,
      typeParameters?: K.TSTypeParameterDeclarationKind | null
    }
  ): N.TSConstructorType & T;
}

export interface TSDeclareFunctionBuilder {
  <T = {}>(
    id: K.IdentifierKind | null | undefined,
    params: K.PatternKind[],
    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null
  ): N.TSDeclareFunction & T;
  from<T = {}>(
    params: {
      async?: boolean,
      comments?: K.CommentKind[] | null,
      declare?: boolean,
      generator?: boolean,
      id?: K.IdentifierKind | null,
      loc?: K.SourceLocationKind | null,
      params: K.PatternKind[],
      returnType?: K.TSTypeAnnotationKind | K.NoopKind | null,
      typeParameters?: K.TSTypeParameterDeclarationKind | null
    }
  ): N.TSDeclareFunction & T;
}

export interface TSDeclareMethodBuilder {
  <T = {}>(
    key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind,
    params: K.PatternKind[],
    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null
  ): N.TSDeclareMethod & T;
  from<T = {}>(
    params: {
      abstract?: boolean,
      access?: "public" | "private" | "protected" | "undefined",
      accessibility?: "public" | "private" | "protected" | "undefined",
      async?: boolean,
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      decorators?: K.DecoratorKind[] | null,
      generator?: boolean,
      key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind,
      kind?: "get" | "set" | "method" | "constructor",
      loc?: K.SourceLocationKind | null,
      optional?: boolean,
      params: K.PatternKind[],
      returnType?: K.TSTypeAnnotationKind | K.NoopKind | null,
      static?: boolean,
      typeParameters?: K.TSTypeParameterDeclarationKind | null
    }
  ): N.TSDeclareMethod & T;
}

export interface TSMappedTypeBuilder {
  <T = {}>(typeParameter: K.TSTypeParameterKind, typeAnnotation?: K.TSTypeKind | null): N.TSMappedType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      optional?: boolean,
      readonly?: boolean,
      typeAnnotation?: K.TSTypeKind | null,
      typeParameter: K.TSTypeParameterKind
    }
  ): N.TSMappedType & T;
}

export interface TSTupleTypeBuilder {
  <T = {}>(elementTypes: K.TSTypeKind[]): N.TSTupleType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      elementTypes: K.TSTypeKind[],
      loc?: K.SourceLocationKind | null
    }
  ): N.TSTupleType & T;
}

export interface TSRestTypeBuilder {
  <T = {}>(typeAnnotation: K.TSTypeKind): N.TSRestType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.TSTypeKind
    }
  ): N.TSRestType & T;
}

export interface TSOptionalTypeBuilder {
  <T = {}>(typeAnnotation: K.TSTypeKind): N.TSOptionalType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.TSTypeKind
    }
  ): N.TSOptionalType & T;
}

export interface TSIndexedAccessTypeBuilder {
  <T = {}>(objectType: K.TSTypeKind, indexType: K.TSTypeKind): N.TSIndexedAccessType & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      indexType: K.TSTypeKind,
      loc?: K.SourceLocationKind | null,
      objectType: K.TSTypeKind
    }
  ): N.TSIndexedAccessType & T;
}

export interface TSTypeOperatorBuilder {
  <T = {}>(operator: string): N.TSTypeOperator & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      operator: string,
      typeAnnotation: K.TSTypeKind
    }
  ): N.TSTypeOperator & T;
}

export interface TSIndexSignatureBuilder {
  <T = {}>(parameters: K.IdentifierKind[]): N.TSIndexSignature & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      parameters: K.IdentifierKind[],
      readonly?: boolean,
      typeAnnotation?: K.TSTypeAnnotationKind | null
    }
  ): N.TSIndexSignature & T;
}

export interface TSPropertySignatureBuilder {
  <T = {}>(key: K.ExpressionKind): N.TSPropertySignature & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      initializer?: K.ExpressionKind | null,
      key: K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      optional?: boolean,
      readonly?: boolean,
      typeAnnotation?: K.TSTypeAnnotationKind | null
    }
  ): N.TSPropertySignature & T;
}

export interface TSMethodSignatureBuilder {
  <T = {}>(key: K.ExpressionKind): N.TSMethodSignature & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      key: K.ExpressionKind,
      loc?: K.SourceLocationKind | null,
      optional?: boolean,
      parameters: (K.IdentifierKind | K.RestElementKind)[],
      typeAnnotation?: K.TSTypeAnnotationKind | null,
      typeParameters?: K.TSTypeParameterDeclarationKind | null
    }
  ): N.TSMethodSignature & T;
}

export interface TSTypePredicateBuilder {
  <T = {}>(
    parameterName: K.IdentifierKind | K.TSThisTypeKind,
    typeAnnotation: K.TSTypeAnnotationKind
  ): N.TSTypePredicate & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      parameterName: K.IdentifierKind | K.TSThisTypeKind,
      typeAnnotation: K.TSTypeAnnotationKind
    }
  ): N.TSTypePredicate & T;
}

export interface TSCallSignatureDeclarationBuilder {
  <T = {}>(parameters: (K.IdentifierKind | K.RestElementKind)[]): N.TSCallSignatureDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      parameters: (K.IdentifierKind | K.RestElementKind)[],
      typeAnnotation?: K.TSTypeAnnotationKind | null,
      typeParameters?: K.TSTypeParameterDeclarationKind | null
    }
  ): N.TSCallSignatureDeclaration & T;
}

export interface TSConstructSignatureDeclarationBuilder {
  <T = {}>(parameters: (K.IdentifierKind | K.RestElementKind)[]): N.TSConstructSignatureDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      parameters: (K.IdentifierKind | K.RestElementKind)[],
      typeAnnotation?: K.TSTypeAnnotationKind | null,
      typeParameters?: K.TSTypeParameterDeclarationKind | null
    }
  ): N.TSConstructSignatureDeclaration & T;
}

export interface TSEnumMemberBuilder {
  <T = {}>(
    id: K.IdentifierKind | K.StringLiteralKind,
    initializer?: K.ExpressionKind | null
  ): N.TSEnumMember & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind | K.StringLiteralKind,
      initializer?: K.ExpressionKind | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSEnumMember & T;
}

export interface TSTypeQueryBuilder {
  <T = {}>(exprName: K.IdentifierKind): N.TSTypeQuery & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      exprName: K.IdentifierKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSTypeQuery & T;
}

export interface TSTypeLiteralBuilder {
  <T = {}>(
    members: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]
  ): N.TSTypeLiteral & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      members: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]
    }
  ): N.TSTypeLiteral & T;
}

export interface TSTypeAssertionBuilder {
  <T = {}>(typeAnnotation: K.TSTypeKind, expression: K.ExpressionKind): N.TSTypeAssertion & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      extra?: {
        "parenthesized": boolean
      } | null,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.TSTypeKind
    }
  ): N.TSTypeAssertion & T;
}

export interface TSEnumDeclarationBuilder {
  <T = {}>(id: K.IdentifierKind, members: K.TSEnumMemberKind[]): N.TSEnumDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      const?: boolean,
      declare?: boolean,
      id: K.IdentifierKind,
      initializer?: K.ExpressionKind | null,
      loc?: K.SourceLocationKind | null,
      members: K.TSEnumMemberKind[]
    }
  ): N.TSEnumDeclaration & T;
}

export interface TSTypeAliasDeclarationBuilder {
  <T = {}>(id: K.IdentifierKind): N.TSTypeAliasDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      declare?: boolean,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null,
      typeAnnotation: K.TSTypeKind,
      typeParameters?: K.TSTypeParameterDeclarationKind | null
    }
  ): N.TSTypeAliasDeclaration & T;
}

export interface TSModuleBlockBuilder {
  <T = {}>(body: K.StatementKind[]): N.TSModuleBlock & T;
  from<T = {}>(
    params: {
      body: K.StatementKind[],
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSModuleBlock & T;
}

export interface TSModuleDeclarationBuilder {
  <T = {}>(
    id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind,
    body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null
  ): N.TSModuleDeclaration & T;
  from<T = {}>(
    params: {
      body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null,
      comments?: K.CommentKind[] | null,
      declare?: boolean,
      global?: boolean,
      id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSModuleDeclaration & T;
}

export interface TSImportEqualsDeclarationBuilder {
  <T = {}>(
    id: K.IdentifierKind,
    moduleReference: K.IdentifierKind | K.TSQualifiedNameKind | K.TSExternalModuleReferenceKind
  ): N.TSImportEqualsDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      isExport?: boolean,
      loc?: K.SourceLocationKind | null,
      moduleReference: K.IdentifierKind | K.TSQualifiedNameKind | K.TSExternalModuleReferenceKind
    }
  ): N.TSImportEqualsDeclaration & T;
}

export interface TSExternalModuleReferenceBuilder {
  <T = {}>(expression: K.StringLiteralKind): N.TSExternalModuleReference & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.StringLiteralKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSExternalModuleReference & T;
}

export interface TSExportAssignmentBuilder {
  <T = {}>(expression: K.ExpressionKind): N.TSExportAssignment & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.ExpressionKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSExportAssignment & T;
}

export interface TSNamespaceExportDeclarationBuilder {
  <T = {}>(id: K.IdentifierKind): N.TSNamespaceExportDeclaration & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      id: K.IdentifierKind,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSNamespaceExportDeclaration & T;
}

export interface TSInterfaceBodyBuilder {
  <T = {}>(
    body: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]
  ): N.TSInterfaceBody & T;
  from<T = {}>(
    params: {
      body: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[],
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null
    }
  ): N.TSInterfaceBody & T;
}

export interface TSExpressionWithTypeArgumentsBuilder {
  <T = {}>(
    expression: K.IdentifierKind | K.TSQualifiedNameKind,
    typeParameters?: K.TSTypeParameterInstantiationKind | null
  ): N.TSExpressionWithTypeArguments & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      expression: K.IdentifierKind | K.TSQualifiedNameKind,
      loc?: K.SourceLocationKind | null,
      typeParameters?: K.TSTypeParameterInstantiationKind | null
    }
  ): N.TSExpressionWithTypeArguments & T;
}

export interface TSInterfaceDeclarationBuilder {
  <T = {}>(id: K.IdentifierKind | K.TSQualifiedNameKind, body: K.TSInterfaceBodyKind): N.TSInterfaceDeclaration & T;
  from<T = {}>(
    params: {
      body: K.TSInterfaceBodyKind,
      comments?: K.CommentKind[] | null,
      declare?: boolean,
      extends?: K.TSExpressionWithTypeArgumentsKind[] | null,
      id: K.IdentifierKind | K.TSQualifiedNameKind,
      loc?: K.SourceLocationKind | null,
      typeParameters?: K.TSTypeParameterDeclarationKind | null
    }
  ): N.TSInterfaceDeclaration & T;
}

export interface TSParameterPropertyBuilder {
  <T = {}>(parameter: K.IdentifierKind | K.AssignmentPatternKind): N.TSParameterProperty & T;
  from<T = {}>(
    params: {
      accessibility?: "public" | "private" | "protected" | "undefined",
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      parameter: K.IdentifierKind | K.AssignmentPatternKind,
      readonly?: boolean
    }
  ): N.TSParameterProperty & T;
}

export interface OptionalMemberExpressionBuilder {
  <T = {}>(
    object: K.ExpressionKind,
    property: K.IdentifierKind | K.ExpressionKind,
    computed?: boolean,
    optional?: boolean
  ): N.OptionalMemberExpression & T;
  from<T = {}>(
    params: {
      comments?: K.CommentKind[] | null,
      computed?: boolean,
      loc?: K.SourceLocationKind | null,
      object: K.ExpressionKind,
      optional?: boolean,
      property: K.IdentifierKind | K.ExpressionKind
    }
  ): N.OptionalMemberExpression & T;
}

export interface OptionalCallExpressionBuilder {
  <T = {}>(
    callee: K.ExpressionKind,
    argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[],
    optional?: boolean
  ): N.OptionalCallExpression & T;
  from<T = {}>(
    params: {
      arguments: (K.ExpressionKind | K.SpreadElementKind)[],
      callee: K.ExpressionKind,
      comments?: K.CommentKind[] | null,
      loc?: K.SourceLocationKind | null,
      optional?: boolean
    }
  ): N.OptionalCallExpression & T;
}

export interface Builders {
  sourceLocation: SourceLocationBuilder;
  position: PositionBuilder;
  file: FileBuilder;
  program: ProgramBuilder;
  identifier: IdentifierBuilder;
  blockStatement: BlockStatementBuilder;
  emptyStatement: EmptyStatementBuilder;
  expressionStatement: ExpressionStatementBuilder;
  ifStatement: IfStatementBuilder;
  labeledStatement: LabeledStatementBuilder;
  breakStatement: BreakStatementBuilder;
  continueStatement: ContinueStatementBuilder;
  withStatement: WithStatementBuilder;
  switchStatement: SwitchStatementBuilder;
  switchCase: SwitchCaseBuilder;
  returnStatement: ReturnStatementBuilder;
  throwStatement: ThrowStatementBuilder;
  tryStatement: TryStatementBuilder;
  catchClause: CatchClauseBuilder;
  whileStatement: WhileStatementBuilder;
  doWhileStatement: DoWhileStatementBuilder;
  forStatement: ForStatementBuilder;
  variableDeclaration: VariableDeclarationBuilder;
  forInStatement: ForInStatementBuilder;
  debuggerStatement: DebuggerStatementBuilder;
  functionDeclaration: FunctionDeclarationBuilder;
  functionExpression: FunctionExpressionBuilder;
  variableDeclarator: VariableDeclaratorBuilder;
  thisExpression: ThisExpressionBuilder;
  arrayExpression: ArrayExpressionBuilder;
  objectExpression: ObjectExpressionBuilder;
  property: PropertyBuilder;
  literal: LiteralBuilder;
  sequenceExpression: SequenceExpressionBuilder;
  unaryExpression: UnaryExpressionBuilder;
  binaryExpression: BinaryExpressionBuilder;
  assignmentExpression: AssignmentExpressionBuilder;
  updateExpression: UpdateExpressionBuilder;
  logicalExpression: LogicalExpressionBuilder;
  conditionalExpression: ConditionalExpressionBuilder;
  newExpression: NewExpressionBuilder;
  callExpression: CallExpressionBuilder;
  memberExpression: MemberExpressionBuilder;
  restElement: RestElementBuilder;
  typeAnnotation: TypeAnnotationBuilder;
  tsTypeAnnotation: TSTypeAnnotationBuilder;
  spreadElementPattern: SpreadElementPatternBuilder;
  arrowFunctionExpression: ArrowFunctionExpressionBuilder;
  forOfStatement: ForOfStatementBuilder;
  yieldExpression: YieldExpressionBuilder;
  generatorExpression: GeneratorExpressionBuilder;
  comprehensionBlock: ComprehensionBlockBuilder;
  comprehensionExpression: ComprehensionExpressionBuilder;
  propertyPattern: PropertyPatternBuilder;
  objectPattern: ObjectPatternBuilder;
  arrayPattern: ArrayPatternBuilder;
  methodDefinition: MethodDefinitionBuilder;
  spreadElement: SpreadElementBuilder;
  assignmentPattern: AssignmentPatternBuilder;
  classPropertyDefinition: ClassPropertyDefinitionBuilder;
  classProperty: ClassPropertyBuilder;
  classBody: ClassBodyBuilder;
  classDeclaration: ClassDeclarationBuilder;
  classExpression: ClassExpressionBuilder;
  importSpecifier: ImportSpecifierBuilder;
  importNamespaceSpecifier: ImportNamespaceSpecifierBuilder;
  importDefaultSpecifier: ImportDefaultSpecifierBuilder;
  importDeclaration: ImportDeclarationBuilder;
  taggedTemplateExpression: TaggedTemplateExpressionBuilder;
  templateLiteral: TemplateLiteralBuilder;
  templateElement: TemplateElementBuilder;
  spreadProperty: SpreadPropertyBuilder;
  spreadPropertyPattern: SpreadPropertyPatternBuilder;
  awaitExpression: AwaitExpressionBuilder;
  letStatement: LetStatementBuilder;
  letExpression: LetExpressionBuilder;
  graphExpression: GraphExpressionBuilder;
  graphIndexExpression: GraphIndexExpressionBuilder;
  jsxAttribute: JSXAttributeBuilder;
  jsxIdentifier: JSXIdentifierBuilder;
  jsxNamespacedName: JSXNamespacedNameBuilder;
  jsxExpressionContainer: JSXExpressionContainerBuilder;
  jsxMemberExpression: JSXMemberExpressionBuilder;
  jsxSpreadAttribute: JSXSpreadAttributeBuilder;
  jsxElement: JSXElementBuilder;
  jsxOpeningElement: JSXOpeningElementBuilder;
  jsxClosingElement: JSXClosingElementBuilder;
  jsxFragment: JSXFragmentBuilder;
  jsxText: JSXTextBuilder;
  jsxOpeningFragment: JSXOpeningFragmentBuilder;
  jsxClosingFragment: JSXClosingFragmentBuilder;
  jsxEmptyExpression: JSXEmptyExpressionBuilder;
  jsxSpreadChild: JSXSpreadChildBuilder;
  anyTypeAnnotation: AnyTypeAnnotationBuilder;
  emptyTypeAnnotation: EmptyTypeAnnotationBuilder;
  mixedTypeAnnotation: MixedTypeAnnotationBuilder;
  voidTypeAnnotation: VoidTypeAnnotationBuilder;
  numberTypeAnnotation: NumberTypeAnnotationBuilder;
  numberLiteralTypeAnnotation: NumberLiteralTypeAnnotationBuilder;
  numericLiteralTypeAnnotation: NumericLiteralTypeAnnotationBuilder;
  stringTypeAnnotation: StringTypeAnnotationBuilder;
  stringLiteralTypeAnnotation: StringLiteralTypeAnnotationBuilder;
  booleanTypeAnnotation: BooleanTypeAnnotationBuilder;
  booleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotationBuilder;
  nullableTypeAnnotation: NullableTypeAnnotationBuilder;
  nullLiteralTypeAnnotation: NullLiteralTypeAnnotationBuilder;
  nullTypeAnnotation: NullTypeAnnotationBuilder;
  thisTypeAnnotation: ThisTypeAnnotationBuilder;
  existsTypeAnnotation: ExistsTypeAnnotationBuilder;
  existentialTypeParam: ExistentialTypeParamBuilder;
  functionTypeAnnotation: FunctionTypeAnnotationBuilder;
  functionTypeParam: FunctionTypeParamBuilder;
  typeParameterDeclaration: TypeParameterDeclarationBuilder;
  arrayTypeAnnotation: ArrayTypeAnnotationBuilder;
  objectTypeAnnotation: ObjectTypeAnnotationBuilder;
  objectTypeProperty: ObjectTypePropertyBuilder;
  objectTypeSpreadProperty: ObjectTypeSpreadPropertyBuilder;
  objectTypeIndexer: ObjectTypeIndexerBuilder;
  objectTypeCallProperty: ObjectTypeCallPropertyBuilder;
  variance: VarianceBuilder;
  qualifiedTypeIdentifier: QualifiedTypeIdentifierBuilder;
  genericTypeAnnotation: GenericTypeAnnotationBuilder;
  typeParameterInstantiation: TypeParameterInstantiationBuilder;
  memberTypeAnnotation: MemberTypeAnnotationBuilder;
  unionTypeAnnotation: UnionTypeAnnotationBuilder;
  intersectionTypeAnnotation: IntersectionTypeAnnotationBuilder;
  typeofTypeAnnotation: TypeofTypeAnnotationBuilder;
  typeParameter: TypeParameterBuilder;
  classImplements: ClassImplementsBuilder;
  interfaceDeclaration: InterfaceDeclarationBuilder;
  interfaceExtends: InterfaceExtendsBuilder;
  declareInterface: DeclareInterfaceBuilder;
  typeAlias: TypeAliasBuilder;
  opaqueType: OpaqueTypeBuilder;
  declareTypeAlias: DeclareTypeAliasBuilder;
  declareOpaqueType: DeclareOpaqueTypeBuilder;
  typeCastExpression: TypeCastExpressionBuilder;
  tupleTypeAnnotation: TupleTypeAnnotationBuilder;
  declareVariable: DeclareVariableBuilder;
  declareFunction: DeclareFunctionBuilder;
  declareClass: DeclareClassBuilder;
  declareModule: DeclareModuleBuilder;
  declareModuleExports: DeclareModuleExportsBuilder;
  declareExportDeclaration: DeclareExportDeclarationBuilder;
  exportSpecifier: ExportSpecifierBuilder;
  exportBatchSpecifier: ExportBatchSpecifierBuilder;
  declareExportAllDeclaration: DeclareExportAllDeclarationBuilder;
  inferredPredicate: InferredPredicateBuilder;
  declaredPredicate: DeclaredPredicateBuilder;
  exportDeclaration: ExportDeclarationBuilder;
  block: BlockBuilder;
  line: LineBuilder;
  noop: NoopBuilder;
  doExpression: DoExpressionBuilder;
  super: SuperBuilder;
  bindExpression: BindExpressionBuilder;
  decorator: DecoratorBuilder;
  metaProperty: MetaPropertyBuilder;
  parenthesizedExpression: ParenthesizedExpressionBuilder;
  exportDefaultDeclaration: ExportDefaultDeclarationBuilder;
  exportNamedDeclaration: ExportNamedDeclarationBuilder;
  exportNamespaceSpecifier: ExportNamespaceSpecifierBuilder;
  exportDefaultSpecifier: ExportDefaultSpecifierBuilder;
  exportAllDeclaration: ExportAllDeclarationBuilder;
  commentBlock: CommentBlockBuilder;
  commentLine: CommentLineBuilder;
  directive: DirectiveBuilder;
  directiveLiteral: DirectiveLiteralBuilder;
  stringLiteral: StringLiteralBuilder;
  numericLiteral: NumericLiteralBuilder;
  bigIntLiteral: BigIntLiteralBuilder;
  nullLiteral: NullLiteralBuilder;
  booleanLiteral: BooleanLiteralBuilder;
  regExpLiteral: RegExpLiteralBuilder;
  objectMethod: ObjectMethodBuilder;
  objectProperty: ObjectPropertyBuilder;
  classMethod: ClassMethodBuilder;
  restProperty: RestPropertyBuilder;
  forAwaitStatement: ForAwaitStatementBuilder;
  import: ImportBuilder;
  tsQualifiedName: TSQualifiedNameBuilder;
  tsTypeReference: TSTypeReferenceBuilder;
  tsTypeParameterInstantiation: TSTypeParameterInstantiationBuilder;
  tsTypeParameterDeclaration: TSTypeParameterDeclarationBuilder;
  tsAsExpression: TSAsExpressionBuilder;
  tsNonNullExpression: TSNonNullExpressionBuilder;
  tsAnyKeyword: TSAnyKeywordBuilder;
  tsBooleanKeyword: TSBooleanKeywordBuilder;
  tsNeverKeyword: TSNeverKeywordBuilder;
  tsNullKeyword: TSNullKeywordBuilder;
  tsNumberKeyword: TSNumberKeywordBuilder;
  tsObjectKeyword: TSObjectKeywordBuilder;
  tsStringKeyword: TSStringKeywordBuilder;
  tsSymbolKeyword: TSSymbolKeywordBuilder;
  tsUndefinedKeyword: TSUndefinedKeywordBuilder;
  tsUnknownKeyword: TSUnknownKeywordBuilder;
  tsVoidKeyword: TSVoidKeywordBuilder;
  tsThisType: TSThisTypeBuilder;
  tsArrayType: TSArrayTypeBuilder;
  tsLiteralType: TSLiteralTypeBuilder;
  tsUnionType: TSUnionTypeBuilder;
  tsIntersectionType: TSIntersectionTypeBuilder;
  tsConditionalType: TSConditionalTypeBuilder;
  tsInferType: TSInferTypeBuilder;
  tsTypeParameter: TSTypeParameterBuilder;
  tsParenthesizedType: TSParenthesizedTypeBuilder;
  tsFunctionType: TSFunctionTypeBuilder;
  tsConstructorType: TSConstructorTypeBuilder;
  tsDeclareFunction: TSDeclareFunctionBuilder;
  tsDeclareMethod: TSDeclareMethodBuilder;
  tsMappedType: TSMappedTypeBuilder;
  tsTupleType: TSTupleTypeBuilder;
  tsRestType: TSRestTypeBuilder;
  tsOptionalType: TSOptionalTypeBuilder;
  tsIndexedAccessType: TSIndexedAccessTypeBuilder;
  tsTypeOperator: TSTypeOperatorBuilder;
  tsIndexSignature: TSIndexSignatureBuilder;
  tsPropertySignature: TSPropertySignatureBuilder;
  tsMethodSignature: TSMethodSignatureBuilder;
  tsTypePredicate: TSTypePredicateBuilder;
  tsCallSignatureDeclaration: TSCallSignatureDeclarationBuilder;
  tsConstructSignatureDeclaration: TSConstructSignatureDeclarationBuilder;
  tsEnumMember: TSEnumMemberBuilder;
  tsTypeQuery: TSTypeQueryBuilder;
  tsTypeLiteral: TSTypeLiteralBuilder;
  tsTypeAssertion: TSTypeAssertionBuilder;
  tsEnumDeclaration: TSEnumDeclarationBuilder;
  tsTypeAliasDeclaration: TSTypeAliasDeclarationBuilder;
  tsModuleBlock: TSModuleBlockBuilder;
  tsModuleDeclaration: TSModuleDeclarationBuilder;
  tsImportEqualsDeclaration: TSImportEqualsDeclarationBuilder;
  tsExternalModuleReference: TSExternalModuleReferenceBuilder;
  tsExportAssignment: TSExportAssignmentBuilder;
  tsNamespaceExportDeclaration: TSNamespaceExportDeclarationBuilder;
  tsInterfaceBody: TSInterfaceBodyBuilder;
  tsExpressionWithTypeArguments: TSExpressionWithTypeArgumentsBuilder;
  tsInterfaceDeclaration: TSInterfaceDeclarationBuilder;
  tsParameterProperty: TSParameterPropertyBuilder;
  optionalMemberExpression: OptionalMemberExpressionBuilder;
  optionalCallExpression: OptionalCallExpressionBuilder;
}